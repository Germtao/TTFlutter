# Inherited Widget多组件状态共享效果。主要是接受两个参数，`name`和`onNameChange`方法，并且有一个判断函数`updateShouldNotify`。前面两个参数不用介绍，关键在于`updateShouldNotify`，这个判断函数的作用就是上面大家的疑惑点。如果将`TestOther`不作为该子组件，那么根据我们之前了解到的知识点，由于`setState`会触发父组件`NameGame`的更新，而子组件会因为父组件的更新，则会引发执行`build`操作。如果`TestOther`是`NameInheritedWidget`的子组件，那么在执行`setState`后，`NameInheritedWidget`会判断状态是否有状态变化，还会判断子组件是否有依赖该`name`状态，从而就保证了两点：1. 状态变化时，如果未使用该状态子组件，则不会发生`build`；2. 使用了该状态组件，如果组件的状态没有发生变化，也不会发生`build`。这两点就非常好地保护了我们刚开始提到的问题，因为有状态父组件的更新，而导致全部子节点的`build`操作。**这里要非常注意，需要使用`NameGameState`方法来封装组件，如果该子组件直接写在`build`中的`child`方法中，就无法利用`NameInheritedWidget`优点，这点大家要特别注意。**总结下`InheritedWidget`实现状态管理的要点：1. 状态提升，将需要共享的状态提升到共同且最近的一个父节点，并使用`InheritedWidget`来管理；2. 该父节点上，将所有子节点作为该节点状态管理类的一个构造函数参数，并且传递给`InheritedWidget`；3. 子节点通过`dependOnInheritedWidgetOfExactType`的方法来获取状态管理类`InheritedWidget`中的属性以及方法。